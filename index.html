<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DirtMC â€” Legendary</title>

<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

<style>
  :root{
    --g1:#06ff7a;
    --g2:#12c86f;
    --bg-dark: #000005;
    --glass: rgba(255,255,255,0.02);
    --muted: rgba(230,255,240,0.95);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg-dark); font-family:"Orbitron", Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; color:var(--muted); overflow:hidden; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}

  /* canvas backdrop */
  canvas#bgCanvas{ position:fixed; inset:0; z-index:0; display:block; background: radial-gradient(ellipse at center, rgba(8,12,6,0.85) 0%, rgba(0,0,0,0.95) 60%); }

  /* splash loader */
  #splash{
    position:fixed; inset:0; z-index:9999; display:flex; align-items:center; justify-content:center; flex-direction:column;
    background:linear-gradient(180deg,#000,#00130a);
  }
  .splash-title{
    font-size:64px; color:var(--g2); font-weight:900; letter-spacing:2px;
    text-shadow: 0 6px 0 rgba(0,0,0,0.6), 0 18px 60px rgba(6,255,140,0.08), 0 0 48px rgba(6,255,140,0.06);
    transform:perspective(700px) rotateX(10deg);
    margin-bottom:24px;
  }
  .loader-wrap{ width:520px; max-width:88%; text-align:center; }
  #loadCounter{ color:var(--g2); font-weight:800; margin-bottom:10px; font-size:18px; }
  .load-bar{ height:14px; border-radius:999px; background: rgba(255,255,255,0.03); overflow:hidden; box-shadow:0 8px 30px rgba(0,0,0,0.6); }
  .load-fill{ width:0%; height:100%; background: linear-gradient(90deg,var(--g1),var(--g2)); border-radius:999px; transition:width .18s linear; box-shadow: inset 0 0 20px rgba(54,255,176,0.06); }

  /* main wrap */
  .wrap{ position:relative; z-index:300; min-height:100vh; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:12px; text-align:center; padding:20px; }

  /* Title 3D + strong glow */
  .title{
    font-size:clamp(34px,8vw,72px); font-weight:900; color:var(--g2);
    text-shadow:
      0 8px 0 rgba(0,0,0,0.7),
      0 20px 60px rgba(6,255,140,0.06),
      0 0 36px rgba(6,255,140,0.12),
      0 0 96px rgba(6,255,140,0.06);
    position:relative;
    transform: translateZ(0);
  }
  .title::after{
    content:"DirtMC";
    position:absolute; left:0; top:10px; right:0; z-index:-1;
    color: rgba(0,0,0,0.7); transform: translateY(12px) skewY(-6deg) scaleY(0.96); filter:blur(0.6px); opacity:0.9;
  }

  /* IP + socials row */
  .row{ display:flex; gap:12px; align-items:center; justify-content:center; margin-top:6px; flex-wrap:wrap; }
  .btn{
    padding:12px 20px; border-radius:12px; font-weight:800; cursor:pointer; border:0; transition:transform .12s ease, box-shadow .12s ease;
    color:white; text-decoration:none; display:inline-flex; align-items:center; gap:8px;
  }
  .btn:active{ transform: translateY(2px); }
  .btn-green{ background: linear-gradient(90deg,#025d33,var(--g2)); box-shadow: 0 14px 50px rgba(6,255,140,0.08); color:#051105; }
  .btn-blue{ background: linear-gradient(90deg,#063e9e,#7ab8ff); box-shadow: 0 14px 50px rgba(122,184,255,0.08); }
  .btn-pink{ background: linear-gradient(90deg,#a1004b,#ff6fb5); box-shadow: 0 14px 50px rgba(255,111,181,0.08); }
  /* strong glow on hover */
  .btn:hover{ transform:translateY(-8px) scale(1.03); }
  .btn-green:hover{ box-shadow: 0 30px 120px rgba(6,255,140,0.18); }
  .btn-blue:hover{ box-shadow: 0 30px 120px rgba(122,184,255,0.14); }
  .btn-pink:hover{ box-shadow: 0 30px 120px rgba(255,111,181,0.14); }

  /* trail piece style (created dynamically) */
  .trail-piece{ position:fixed; pointer-events:none; z-index:250; border-radius:999px; filter: blur(8px); transform-origin:left center; opacity:1; }

  /* short "shock" CSS for page shake & blur */
  .shock-anim{
    animation:shockTranslate .6s cubic-bezier(.25,.46,.45,.94);
    filter: blur(1.2px) contrast(1.05);
  }
  @keyframes shockTranslate{
    0%{ transform: translate(0,0); }
    10%{ transform: translate(-6px,4px); }
    30%{ transform: translate(6px,-6px); }
    50%{ transform: translate(-4px,4px); }
    70%{ transform: translate(4px,-2px); }
    100%{ transform: translate(0,0); }
  }

  @media(max-width:640px){
    .title{ font-size:36px; }
    .btn{ padding:10px 14px; font-size:14px; }
  }
</style>
</head>
<body>

<canvas id="bgCanvas" aria-hidden="true"></canvas>

<!-- SPLASH -->
<div id="splash" role="status" aria-live="polite">
  <div class="splash-title">DirtMC</div>
  <div class="loader-wrap">
    <div id="loadCounter">0%</div>
    <div class="load-bar" style="margin-top:8px;">
      <div id="loadFill" class="load-fill"></div>
    </div>
  </div>
</div>

<!-- MAIN -->
<main class="wrap" id="main" aria-hidden="true" style="display:none;">
  <div class="title">DirtMC</div>

  <div class="row">
    <button id="ipBtn" class="btn btn-green" aria-label="Copy server IP">dirtmc.pro:21411</button>
    <a class="btn btn-blue" href="https://discord.gg/dirtmc" target="_blank" rel="noopener">ðŸ’¬ Discord</a>
    <a class="btn btn-pink" href="https://www.tiktok.com/@dirtmc_" target="_blank" rel="noopener">ðŸŽµ TikTok</a>
  </div>
</main>

<script>
/* ----------------------------
   Loader (counter above bar)
   ---------------------------- */
const splash = document.getElementById('splash');
const loadFill = document.getElementById('loadFill');
const loadCounter = document.getElementById('loadCounter');
const main = document.getElementById('main');

(function splashLoader(){
  let pct = 0;
  const stages = [28, 62, 88, 100];
  function go(i=0){
    if(i >= stages.length){
      loadFill.style.width = '100%'; loadCounter.innerText = '100%';
      setTimeout(()=> {
        splash.style.transition = 'opacity .6s ease'; splash.style.opacity = 0;
        setTimeout(()=> { splash.remove(); main.style.display = 'flex'; main.setAttribute('aria-hidden','false'); }, 700);
      }, 300);
      return;
    }
    const target = stages[i];
    const t = setInterval(()=> {
      pct += Math.max(0.35, (target - pct) * 0.12);
      loadFill.style.width = Math.min(pct, target) + '%';
      loadCounter.innerText = Math.round(Math.min(pct, target)) + '%';
      if(pct >= target - 0.5){
        clearInterval(t);
        setTimeout(()=> go(i+1), 220 + Math.random()*360);
      }
    }, 28);
  }
  go(0);
})();

/* ----------------------------
   Copy IP button
   ---------------------------- */
const ipBtn = document.getElementById('ipBtn');
ipBtn.addEventListener('click', async ()=>{
  const old = ipBtn.textContent;
  try{
    await navigator.clipboard.writeText('dirtmc.pro:21411');
    ipBtn.textContent = 'âœ” Copied';
  }catch(e){
    const ta = document.createElement('textarea'); ta.value='dirtmc.pro:21411'; document.body.appendChild(ta);
    ta.select(); document.execCommand('copy'); ta.remove();
    ipBtn.textContent = 'âœ” Copied';
  }
  setTimeout(()=> ipBtn.textContent = old, 1400);
});

/* ----------------------------
   Canvas: Black Hole center + meteors + radial waves every 60s
   - optimized for performance
   ---------------------------- */
(function(){
  const canvas = document.getElementById('bgCanvas');
  const ctx = canvas.getContext('2d');

  // DPR & resize
  let DPR = Math.max(1, window.devicePixelRatio || 1);
  function resize(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(window.innerHeight * DPR);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  const W = ()=> window.innerWidth;
  const H = ()=> window.innerHeight;
  const cx = ()=> W()/2;
  const cy = ()=> H()/2;

  // stars background
  const stars = [];
  function initStars(){
    stars.length = 0;
    const count = Math.max(120, Math.floor((W()*H())/25000));
    for(let i=0;i<count;i++){
      stars.push({
        x: Math.random()*W(),
        y: Math.random()*H(),
        r: Math.random()*1.8 + 0.2,
        a: Math.random()*0.9 + 0.2
      });
    }
  }
  initStars();
  window.addEventListener('resize', initStars);

  // black hole particles (spiral)
  let particles = [];
  function initParticles(){
    particles = [];
    const area = W()*H();
    const count = Math.max(260, Math.min(900, Math.floor(area / 1400)));
    for(let i=0;i<count;i++){
      particles.push({
        angle: Math.random()*Math.PI*2,
        radius: Math.random()*Math.min(W(),H())*0.6,
        speed: 0.0006 + Math.random()*0.003,
        size: Math.random()*2.2 + 0.2,
        hue: 150 + Math.random()*40,
        layer: Math.random()
      });
    }
  }
  initParticles();
  window.addEventListener('resize', initParticles);

  // meteors (niazak) - streaks with speed
  const meteors = [];
  function spawnMeteor(){
    // spawn from random edge, fly across
    const side = Math.floor(Math.random()*4);
    let x,y, vx, vy;
    const speed = 6 + Math.random()*10;
    const len = 80 + Math.random()*200;
    if(side===0){ // top
      x = Math.random()*W(); y = -40;
      vx = (Math.random()-0.5)*3; vy = speed;
    } else if(side===1){ // right
      x = W()+40; y = Math.random()*H();
      vx = -speed; vy = (Math.random()-0.5)*4;
    } else if(side===2){ // bottom
      x = Math.random()*W(); y = H()+40;
      vx = (Math.random()-0.5)*3; vy = -speed;
    } else { // left
      x = -40; y = Math.random()*H();
      vx = speed; vy = (Math.random()-0.5)*4;
    }
    meteors.push({x,y,vx,vy,len,life:0,ttl: Math.floor(100 + Math.random()*200), hue: 30 + Math.random()*120});
  }

  // spawn meteors intermittently
  setInterval(()=> {
    // spawn 0-2 meteors depending on screen size
    const n = (Math.random() > 0.6 ? 1 : 0) + (Math.random()>0.9?1:0);
    for(let i=0;i<n;i++) spawnMeteor();
  }, 600);

  // radial waves (shock) array
  const waves = [];
  function spawnWave(){
    waves.push({r:30, maxR: Math.min(W(),H())*0.95, alpha:0.85});
    // trigger screen shock class for brief time
    document.documentElement.classList.add('shock-anim');
    setTimeout(()=> document.documentElement.classList.remove('shock-anim'), 700);
  }
  // spawn every 60s
  const WAVE_INTERVAL_MS = 60000; // 60s
  // start after 12s then every 60s
  setTimeout(()=> { spawnWave(); setInterval(spawnWave, WAVE_INTERVAL_MS); }, 12000);

  // initial smaller wave to show effect a bit earlier
  setTimeout(()=> spawnWave(), 4000);

  // main draw loop
  function draw(){
    ctx.clearRect(0,0,W(),H());

    // deep space gradient
    const bgGrad = ctx.createLinearGradient(0,0,H(),H());
    bgGrad.addColorStop(0, '#00000a');
    bgGrad.addColorStop(1, '#001110');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0,0,W(),H());

    // faint stars
    for(let s of stars){
      ctx.beginPath();
      ctx.fillStyle = `rgba(255,255,255,${s.a*0.6})`;
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }

    // draw waves under everything (big translucent rings)
    for(let i=waves.length-1;i>=0;i--){
      const wv = waves[i];
      wv.r += 8; // expansion speed
      wv.alpha *= 0.992;
      if(wv.r > wv.maxR || wv.alpha < 0.01) { waves.splice(i,1); continue; }

      const g = ctx.createRadialGradient(cx(), cy(), wv.r*0.02, cx(), cy(), wv.r);
      g.addColorStop(0, `rgba(6,255,140,${0.08 * wv.alpha})`);
      g.addColorStop(0.4, `rgba(6,255,140,${0.035 * wv.alpha})`);
      g.addColorStop(1, `rgba(6,255,140,0)`);
      ctx.beginPath();
      ctx.fillStyle = g;
      ctx.arc(cx(), cy(), wv.r, 0, Math.PI*2);
      ctx.fill();
    }

    // black hole core shimmer (3D-like)
    const coreR = Math.min(W(),H()) * 0.18;
    // rotating subtle rings for depth
    ctx.save();
    ctx.translate(cx(),cy());
    const t = performance.now() * 0.00012;
    for(let i=0;i<4;i++){
      ctx.rotate(0.002 + i*0.0007 + t*0.04);
      ctx.beginPath();
      ctx.strokeStyle = `rgba(6,255,140,${0.06 - i*0.012})`;
      ctx.lineWidth = 1.2 + (1.1 - i*0.25);
      ctx.ellipse(0, 0, coreR*(1+0.12*i), coreR*(0.52+0.08*i), 0, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();

    // particles spiral into core
    for(let p of particles){
      p.angle += p.speed * (1 + p.layer*0.6);
      p.radius *= (0.999 + p.layer*0.0007);
      if(p.radius < coreR*0.14) p.radius = coreR + Math.random()*(Math.min(W(),H())*0.6);

      const x = cx() + Math.cos(p.angle) * p.radius;
      const y = cy() + Math.sin(p.angle) * p.radius;

      // glow trail (short)
      ctx.beginPath();
      const hx = cx() + Math.cos(p.angle - p.speed*8) * (p.radius + 8);
      const hy = cy() + Math.sin(p.angle - p.speed*8) * (p.radius + 8);
      const grad = ctx.createLinearGradient(x,y,hx,hy);
      grad.addColorStop(0, `rgba(6,255,140,${0.02 + (1-p.layer)*0.28})`);
      grad.addColorStop(1, 'rgba(6,255,140,0)');
      ctx.strokeStyle = grad;
      ctx.lineWidth = Math.max(0.3, p.size*0.8);
      ctx.beginPath();
      ctx.moveTo(x,y);
      ctx.lineTo(hx,hy);
      ctx.stroke();

      // tiny particle dot
      ctx.beginPath();
      ctx.fillStyle = `rgba(6,255,140,${0.5 + (1-p.layer)*0.5})`;
      ctx.arc(x,y, p.size, 0, Math.PI*2);
      ctx.fill();
    }

    // draw black-hole core (strong glow)
    const coreGrad = ctx.createRadialGradient(cx(),cy(), coreR*0.02, cx(),cy(), coreR);
    coreGrad.addColorStop(0, 'rgba(2,12,6,0.98)');
    coreGrad.addColorStop(0.18, 'rgba(6,255,140,0.95)');
    coreGrad.addColorStop(0.45, 'rgba(10,60,30,0.7)');
    coreGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.beginPath();
    ctx.fillStyle = coreGrad;
    ctx.arc(cx(), cy(), coreR, 0, Math.PI*2);
    ctx.fill();

    // core black center
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,1)';
    ctx.arc(cx(), cy(), coreR*0.28, 0, Math.PI*2);
    ctx.fill();

    // meteors draw & update
    for(let i=meteors.length-1;i>=0;i--){
      const m = meteors[i];
      // update
      m.x += m.vx;
      m.y += m.vy;
      m.life++;
      // draw streak
      const ex = m.x - m.vx * (m.len*0.06);
      const ey = m.y - m.vy * (m.len*0.06);

      const g = ctx.createLinearGradient(m.x,m.y, ex, ey);
      g.addColorStop(0, `rgba(255,255,255,0.98)`);
      g.addColorStop(0.2, `hsla(${m.hue},90%,60%,0.9)`);
      g.addColorStop(1, `rgba(2,8,6,0)`);
      ctx.strokeStyle = g;
      ctx.lineWidth = Math.max(1.4, Math.min(6, m.len/40));
      ctx.beginPath();
      ctx.moveTo(m.x,m.y);
      ctx.lineTo(ex,ey);
      ctx.stroke();

      // head glow
      ctx.beginPath();
      ctx.fillStyle = `rgba(255,255,255,0.95)`;
      ctx.arc(m.x, m.y, Math.max(1.6, Math.min(6, m.len/60)), 0, Math.PI*2);
      ctx.fill();

      // remove if offscreen or life exceeded
      if(m.x < -200 || m.x > W()+200 || m.y < -200 || m.y > H()+200 || m.life > m.ttl) {
        meteors.splice(i,1);
      }
    }

    requestAnimationFrame(draw);
  }

  // spawn meteors occasionally with some randomness
  setInterval(()=> {
    // spawn between 0 and 3 meteors depending on screen size & randomness
    const chance = Math.random();
    const maxSpawn = (W()*H() > 1200000) ? 3 : 2;
    const n = (chance>0.6?1:0) + (chance>0.94?1:0);
    for(let i=0;i<n;i++) spawnMeteor();
  }, 900);

  function spawnMeteor(){
    // spawn from a random edge with strong velocity toward general center area or diagonal
    const side = Math.floor(Math.random()*4);
    let x,y,vx,vy;
    const baseSpeed = 8 + Math.random()*12;
    const len = 120 + Math.random()*240;
    if(side===0){ x = Math.random()*W(); y = -60; vx = (Math.random()-0.5)*6; vy = baseSpeed; }
    else if(side===1){ x = W()+60; y = Math.random()*H(); vx = -baseSpeed - Math.random()*4; vy = (Math.random()-0.5)*6; }
    else if(side===2){ x = Math.random()*W(); y = H()+60; vx = (Math.random()-0.5)*6; vy = -baseSpeed - Math.random()*4; }
    else { x = -60; y = Math.random()*H(); vx = baseSpeed + Math.random()*4; vy = (Math.random()-0.5)*6; }
    const ttl = 120 + Math.floor(Math.random()*240);
    const hue = Math.floor(30 + Math.random()*120);
    meteors.push({x,y,vx,vy,len,life:0,ttl,hue});
  }

  // start draw
  draw();

})();

/* ----------------------------
   Waves already spawn every 60s via spawnWave inside canvas closure.
   Additionally, apply small screen-wide "glitch" effect occasionally for cinematic feel.
   (handled by adding 'shock-anim' class on <html> during spawnWave).
   ---------------------------- */

</script>
</body>
</html>
